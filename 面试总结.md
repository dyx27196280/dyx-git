1.系统分类：

ERP系统: ERP是将企业所有资源进行整合集成管理，简单的说是将企业的三大流：物流，资金流，信息流进行全面一体化管理的管理信息系统。

CRM:企业利用相应的信息技术以及[互联网](https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91)技术来协调企业与顾客间在销售、营销和服务上的交互，从而提升其[管理方式](https://baike.baidu.com/item/%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F/260899)，向客户提供创新式的个性化的客户交互和服务的过程。

BOS:物流系统

OA:办公自动化系统

JBPM:Java Busiiness Process Management(业务流程管理),开源工作流产品,采用XML结构的流程描述语言JPDL来描述工作流程。使用Hibernate作为持久层工具。

工作流（Workflow）:工作的流程通过程序管理起来，以表单审核和任务办理为主体，实现办公自动化。

2.什么是分布式：

按照功能点把系统拆分，拆分成独立的功能。单独为某一个节点添加服务器。需要系统之间配合才能完成整个业务逻辑。叫做分布式

优点：

1、把模块拆分，使用接口通信，降低模块之间的耦合度。

2、把项目拆分成若干个子项目，不同的团队负责不同的子项目。

3、增加功能时只需要再增加一个子项目，调用其他系统的接口就可以。

4、可以灵活的进行分布式部署。

缺点：

1、系统之间交互需要使用远程通信，接口开发增加工作量，性能下降。

2、各个模块有一些通用的业务逻辑无法共用。

SOA：面向服务的架构。也就是把工程拆分成服务层、表现层两个工程。服务层中包含业务逻辑，只需要对外提供服务即可。表现层只需要处理和页面的交互，业务逻辑都是调用服务层的服务来实现。表现层和服务层通过dubbo实现通信。

传统的C/S架构、B/S架构：C/S架构基于客户端和浏览器，大部分运行在客户机上，效率高，需要安装客户端，软件升级维护不方便；B/S架构维护升级方便，不需安装客户端，只用能登录服务器即可

3.dubbo和zookeeper：

远程通信的方式：WebService、http+json（调用关系混乱）、dubbo

dubbo使用rpc协议进行远程调用，直接使用socket通信。使用二进制进行通讯，传输效率高，并且可以统计出系统之间的调用关系、调用次数。

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/f8dfe63a3bbc4b69ab852f2d8332a44d/ip_image002.jpeg)

Provider: 暴露服务的服务提供方。

Consumer: 调用远程服务的服务消费方。

Registry: 服务注册与发现的注册中心。

Monitor: 统计服务的调用次数和调用时间的监控中心。

Container: 服务运行容器。

调用关系：

\0. 服务容器负责启动，加载，运行服务提供者。

\1. 服务提供者在启动时，向注册中心注册自己提供的服务。

\2. 服务消费者在启动时，向注册中心订阅自己所需的服务。

\3. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。

\4. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。

\5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

zookeeper：注册中心，负责服务地址的注册与查找

eureka服务

4.序列化与反序列化

序列化实际上就是将一个对象”流化”,被序列化后的对象能够在网络上进行传输

当一个用户访问了服务器,在用户访问后，会在服务器内存中产生一个session(会话)，当用户很长时间没有再次对服务器发出请求，那么服务器会将该会话写入到文件系统中或者是数据库中(不管是很长时间没有再次向服务器发送请求或者是退出登录，会话都不会立马被销毁)，这种将内存中的数据读取并能写入到数据库或者是文件系统叫序列化。当用户再次向服务器发出请求，那么会话将会被激活，这时候就会将会话从文件系统或者是数据库中读取并且重新写入到内存中，这种就叫做“反序列化”

5.文件上传系统：

FastDFS是用c语言编写的一款开源的分布式文件系统。充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，

Tracker server作用是负载均衡和调度，通过Tracker server在文件上传时可以根据一些策略找到Storage server提供文件上传服务。可以将tracker称为追踪服务器或调度服务器。

Storage server作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server没有实现自己的文件系统而是利用操作系统 的文件系统来管理文件。可以将storage称为存储服务器。

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/80f445005d7641d3878a759416bb617a/ip_image002.jpeg)

6.项目架构分布

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/e054fd1ea7f2482b832ea635cb440e21/lip_image002.png)



7.CMS系统：内容管理系统

需要内容分类表和内容表。内容分类表存储树形结构的数据。二者一对多的关系

8.redis的应用场景：

Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库

字符串类型(string)、散列类型(hash)、列表类型(list)、集合类型(set)、有序集合类型(zset)

应用场景：缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）

分布式集群架构中的session分离。聊天室的在线好友列表。任务队列。（秒杀、抢购、12306等等）

应用排行榜。网站访问统计。数据过期处理（可以精确到毫秒）

数据类型分类：

1.String ：字符串  可以存储任何类型的数据，因为任何数据类型都可以表示为二进制。

redis的字符串是二进制安全的，简单理解就是存入什么数据取出的还是什么数据。不会对存储进去的二进制数据进行处理，存入什么数据取出还是什么数据。

应用：商品编号、订单号采用String的递增数字特性生成

2.hash（散列）：商品id、商品名称、商品描述、商品库存、商品好评、存储商品信息

3.list（列表）：双向链表  应用：商品评论列表

4.set（集合）：

5.zset(有序集合)：商品销售排行榜



持久化：方式分为2种，一种RDB方式，一种AOF方式

RDB方式的持久化是通过快照完成的，当符合一定条件时Redis会自动将内存通过RDB方式实现持久化，这种方式大大提高了数据的存储和读取的效率，但是性能受到影响，占用CPU，而且一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件，减少了CPU的占用，提高了性能，此外，就算宕机，数据也不会丢失，成本高。

主从复制：一个主redis可以有多个从redis，主redis中写入数据后，通过主从复制会复制到从redis服务中



redis集群：Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点



9.solr集群

3个zookeeper，建议是奇数节点，实现zookeeper的高可用

4个tomcat节点

solr的好处：solr查询比直接从数据库查询快，数据越大优势越明显。严格来说，lucene负责数据存储，而solr只是一个引擎提供搜索和插入而已，跟数据库的解释器一样。solr的分词器会去匹配分词中

的词去搜索，大大提高了搜索效率，而普通的数据库查询使用的是like查询，效率很低

10.消息中间件

为什么用mq?

Message Queue,是一种跨进程的通信机制，用于上下游传递信息，（逻辑解耦和物理解耦）

1）数据驱动的任务依赖

2）上游不关心多下游执行结果

3）异步返回执行时间长

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/e98c71008ae84c38915723d5282e6462/5.png)



主要应用：

（1）实现系统异步通讯：如用户注册，注册时同时发送邮件和发送短信，减少系统的响应时间

（2）扩展解耦能力：后台添加一个商品后，将商品信息同步到全文检索中，使用消息队列解耦（发布与订阅）

（3）访问高峰期服务器人数控制：秒杀实现（消息队列）

核心：消息代理和目的地（消息发送者发送消息后，将有消息代理接管，将消息发送到目的地）



消息传递形式：

1）队列（queue）：点对点通讯：消息有唯一的接收者和发送者

2）主题(topic)：发布者/订阅者通讯：消息可以有多个接受者

activemq是JMS实现。所谓JMS即java消息服务，是基于JVM消息代理的规范

rabbitmq是AMOP的实现。所谓AMOP即高级消息队列协议，也是一个消息代理的规范，兼容JMS。exchange四种类型：direct、fanout、topic、header

11.详情页面：

使用redis作为缓存，先从redis中查询，查到缓存，直接返回；缓存中没有，查询数据库，把数据放到缓存中，设置缓存时间，返回数据

12.单点登录系统

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/50e4cebf039147848cde6eb88f935c46/lip_image002.png)

登录的处理流程：

1、登录页面提交用户名密码。

2、登录成功后生成token。Token相当于原来的jsessionid，字符串，可以使用uuid。

3、把用户信息保存到redis。Key就是token，value就是TbUser对象转换成json。

4、使用String类型保存Session信息。可以使用“前缀:token”为key

5、设置key的过期时间。模拟Session的过期时间。一般半个小时。

6、把token写入cookie中。

7、Cookie需要跨域。例如www. itrip.com\sso.itrip.com\order. itrip.com，可以使用工具类。

8、Cookie的有效期。关闭浏览器失效。

9、登录成功。

使用jsonp进行跨域请求,通过工具类完成：

1、判断参数中是否有callback。

2、如果有，要进行跨域处理

第三方登录：

要集成第三方登录，首先需要去QQ、微信、支付宝等一些大型第三方平台申请权限。第三方登录时遵循一个Oauth2.0的协议，该协议规定了允许各大互联网公司的账号在不泄漏密码的情况下在其它网站登录，获取相关信息。根据该协议，去各大第三方账号网站注册，获取唯一性id和secret安全码，集成第三方账号登录图标，并在注册时在第三方设置回调地址到本地controller层 登录方法。

当用户点击第三方登录时，会让用户跳转到第三方登录界面，用户登录成功后，第三方会根据回调地址发送一个code随机码，用来标识用户，接到该code码，我们利用httpclient模拟的http请求向第三方发送一次请求，传递我们注册时填写的apikey和accesskey，包括传过来的code,用来获取token。然后利用webService调用第三方接口，从而通过第三方返回的xml信息，判断用户是否进行过绑定，根据判定后的绑定信息，确认账号是否在我们网站登录过。如果是第一次登录，给第三方发送一个绑定账号请求，跳转到用户信息界面完善信息，保存第三方账号信息到我们网站数据库中；如果已经登录过，根据第三方账号信息去数据库查询出信息，保存到session中，跳转到首页。

多用户同时登陆同一账号：

可以用户表的基础上，新建一个账号session表，用来记录用户的id和最后一个登陆的sessionId,然后修改登录方法，每次登录成功后，要将登录用户信息写入Session的同时还要更新用户session表里相应账户的sessionId，，然后要修改获取当前用户信息的方法，在里面要做两重判断，首先，看当前会话是否存在登录用户信息，如果没有，则肯定是未登录，如果有，还要再进一步要用当前用户表里存的用户Id去用户session表查询sessionId，与当前用户中的sessionId作比较，如果是一致的，说明当前会话是最新的会话，登录状态正常，如果不一致，说明在当前登录会话创建后，被新的登录会话覆盖掉了，当前的登录会话已经失效，这时候，服务器应该删除当前的登录会话并返回提示给客户端，至此，限制账户同一时间单终端登录功能便实现了。



cookie安全问题：网络传输时使用https尽量避免cookie的泄露

http和https:http超文本传输协议，明文传输，https需要申请ca证书，要交钱，具有安全性的ssl加密传输协议；http使用端口为80，https使用端口443



12.购物车

购物车一般分为2种:用户未登录可添加（京东购物车）和用户未登录不可添加商品（淘宝购物车）。

淘宝购物车用户登录状态下添加商品，会进行校验，将商品持久化到后台，而用户未登录状态下添加商品将自动跳转到登录页面，增加了用户的操作。相比而言，京东购物车用户体验更好，当用户未登录时，添加商品时获取cookie中的购物车，如果没有就创建购物车对象，将当前商品追加到购物车，写入cookie中，设置cookie的有效时间，当用户登录后会从cookie中读取信息，同步到用户购物车，存入redis中，然后删除cookie。购物车回显时判断用户是否登录，如果用户没有登录显示本地cookie缓存中的商品信息，如果用户登录直接查询持久化数据库中的商品信息进行购物车回显。

        但cookie存在一些安全问题，比如浏览器会篡改cookie,cookie存储上限（4k左右），cookie对后台服务器的压力。cookie不适合大量数据的存储，因为它们由每个对服务器的请求来传递，使得cookie的传递速度很慢且效率不高，而html5中数据不是由每个服务器请求传递的，而是只有在请求时使用数据，它使得不影响网站的性能的情况下存储大量的数据成为可能。分为localStorage（5M存储）和sessionStorage，前者没有时间限制的数据存储，后者针对一个session的数据存储。利用localStorage进行购物车添加，在添加时将商品信息写入localStorage中，当用户登录时同步到购物车，立刻销毁localStorage，因为localStorage没有存储时间限制，可能会造成浏览器卡顿，不销毁会加大后台服务器的压力。

13.quartz：任务日常管理系统

Scheduler – 核心调度器   、Job – 任务

JobDetail – 任务描述   、Trigger  -- 触发器

14.支付原理及安全问题

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/2ea5fd65cf5a4451b3914c3a22201a29/%E6%94%AF%E4%BB%98%E5%8E%9F%E7%90%86.png)

15.数据库中间件(mycat):将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。

数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式。

（1）一种是数据的垂直（纵向）切分—一般按照业务切分

（2）一种是数据的逻辑关系，水平（横向）切分。

MySQL来说，标准的读写分离是主从模式，一个写节点Master后面跟着多个读节点，读节点的数量取决于系统的压力，通常是1-3个读节点的配置

16.shiro

用户登录至少需要的表：用户表、角色表、权限表、用户角色表、角色权限表

Authentication：身份认证/登录，验证用户是不是拥有相应的身份；

Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能进行什么操作，如：验证某个用户是否拥有某个角色。或者验证某个用户对某个资源是否具有某个权限；

Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境，也可以是 Web 环境的；

Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；

1、首先调用 Subject.login(token) 进行登录，其会自动委托给 SecurityManager

2、SecurityManager 负责真正的身份验证逻辑；它会委托给 Authenticator 进行身份验证；

3、Authenticator 才是真正的身份验证者，Shiro API 中核心的身份 认证入口点，此处可以自定义插入自己的实现；

4、Authenticator 可能会委托给相应的 AuthenticationStrategy 进 行多 Realm 身份验证，默认 ModularRealmAuthenticator 会调用 AuthenticationStrategy 进行多 Realm 身份验证；

5、Authenticator 会把相应的 token 传入 Realm，从 Realm 获取 身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。

默认拦截器：anon(不需登录就可以访问)、authc

17.数据库优化：

1）使用索引：索引就像书的目录，通过书的目录可以准确定位到具体的位置

索引的原理是平衡树，分为聚集索引和非聚集索引

2）不使用子查询，优先使用左连接

3）避免函数索引

4）用in来代替or

5)  like双百分号无法使用索引

6）通过limit控制读取适当的记录

7）分组统计可以禁止排序

8）批量插入

18.设计模式

设计模式包括：

简单工厂

单例模式：一个类只有一个实例，提供一个全局访问点，禁止拷贝，节省资源，分为懒汉式和饿汉式；懒汉式：类加载时不初始化，线程不安全；饿汉式：类加载时已完成了初始化，类加载比较慢，但获取对象速度快

适配器：spring中aop的处理

包装器：动态的给对象添加额外的职责

代理：为其他对象提供一种代理以控制对这个对象的访问

观察者：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变后，所有依赖于它的对象都得到通知，并自动更新模板方法



六大原则

1.单一职能原则：是最简单的面向对象设计原则，一个类只负责一个一个功能领域中的相应之职责。是实现高内聚，低耦合的指导方针。

2.开闭原则（OCP）:一个软件实体应当对扩展开放，对修改关闭。即软件实体应当尽量在不修改原有代码的情况下进行扩展。软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。抽象化是开闭原则的关键

3.里氏替换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。是实现开闭原则的重要方式之一。

4.依赖倒置原则（DIP）：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

5.接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。

6.迪米特原则：一个软件实体应当尽可能少的与其他实体发生相互作用。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。

19.java代码优化

1）尽量指定类的final修饰符，带有final修饰符的类是不可派生的

2）尽量重用对象，特别是String对象的使用中，出现字符串连接情况时应用StringBuffer代替

3）尽量使用局部变量，调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中，速度较快

4）不要重复初始化变量

5）java+Oracle的应用中，java中内嵌的sql语句尽量大写

6）I/O操作及时释放资源

7）保证过期对象的及时回收

8）使用同步机制时，尽量使用方法同步代替代码块同步

9）减少对变量的重复计算

10）尽量采用懒加载的策略，即在需要的时候才开始创建

11）代码重构，增强代码的可读性

20.SpringMVC的运行原理

用户发送请求到前端控制器，调用处理器映射器找到处理器，处理器返回处理器执行链（处理器拦截器和处理器对象）到前端控制器，通过处理器适配器调用具体的处理器，处理器返回ModelAndView对象给处理器适配器在返回给前端控制器，通过前端控制器进行视图解析，获得返回视图，进行渲染后响应给用户

21.拦截器的运行原理：

大部分拦截器方法都是通过代理（java反射机制）的方式来调用的。当请求到达处理器适配器时，会查找配置文件，并根据配置实例化相对的拦截器对象，串成一个列表，最后一个个调用。拦截器是AOP的一个实现，在访问被拦截的字段或方法时，拦截器链就按照定义的顺序进行调用

22.过滤器的运行原理

过滤器可以简单理解为“取你所想取”，过滤器关注的是web请求，是基于函数回调来实现的，依赖于servlet容器，可以对所有请求起作用，过滤器只能在容器初始化时调用一次

23.mybatis一级二级缓存

一级缓存：底层是hashMap，作用域在sqlSession范围，关闭会话，清除缓存 

二级缓存：全局缓存，需要在mapper.xml中设置缓存，默认未开启，可以手动开启二级缓存

现在缓存工具一般选择ehache或直接使用redis作为缓存

24.redis

启动方式：进入bin目录 1）./redis-server    2) ./redis-server  redis.conf

redis锁三种方式：incr、setnx、set

incr：key不存在，那么key的值会先被初始化为0，再执行incr操作加一，在其它用户执行incr操作进行加一时,返回的值大于说明这个锁正在使用中







锁的特性：1）互斥性（任意时刻只有一个客户端持有锁）；2）不会发生死锁；3）容错性；4）加锁和解锁的同一性

redis是线程安全，本身是单线程，只不过很多时候一台机器会部署多台redis作集群。

单线程运行，和memcached的多线程相比，整体性能偏低，IO是串行化的，因此当单条数据太大时，由于需要等待一个命令的所有IO完成才能进行后续的操作，性能相对偏低。

内存使用上说，redis和memcached不相伯仲；但是对于简单且有规律的key value存储，用redis的hash结构来做，内存使用会惊人的变小，优势明显。

25.接口和抽象类

不同点：

1）抽象类可以有构造方法，接口中不能有构造方法

2）抽象类中可以有普通成员变量，可以定义静态常量，接口中没有普通成员变量，只能定义静态常量

3）一个类可以实现多个接口，只能继承一个类

4）接口中不能有普通方法实现，抽象类可以有普通方法实现

相同点：

不能被实例化，可以包含抽象方法，子类必须重写父类的抽象方法

26.多线程实现

继承Thread类，重载run方法；实现Runable接口，实现run方法

线程安全问题的原因：多个线程共享同一资源时，一个线程未完成全部操作，其他线程修改了数据，造成数据安全问题。

线程同步的方法：同步方法、同步代码块、使用重入锁

死锁：2个线程都在等待对方先完成，造成程序的阻塞

27.事务的特性及隔离级别：

隔离级别：

1）default：默认的事务隔离级别，跟具体的数据库有关，mysql默认的数据隔离级别是repeatable——read;2)read_uncommitted:读未提交，一个事务可以感知或者操作另外一个未提交的事务，可能出现脏读、不可重复读、幻读；3）read_committed:读已提交，一个事务只能感知或者操作另外一个已经提交的事务，可能出现不可重复读和幻读；4）repeatable_read:可重复读，能够避免脏读、不可重复读，不能避免幻读；5）serializable:串行化，最高隔离级别，消耗资源最低，代价最高，能够防止脏读、不可重复读、幻读

四大特性(ACID)：

1）原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么同时成功，要么同时失败；2）一致性：数据不会因为事务的执行而遭到破坏；3）隔离性：一个事务的执行，不受其他事务的干扰；4）持久性：一个事务一旦提交，对数据库的改变是永久的

三大常见事务并发：

脏读：A事务读取了B事务未提交的数据，B事务操作失败进行了回滚

不可重复读：A事务两次读取同一数据之间，B事务对该数据进行了操作（修改或删除），两次读取的数据是不同的

幻读：A事务查询符合条件的数据，B事务插入了一条符合条件的数据，A事务再次查询，发现两次结果不一样

spring事务的传播行为：

28.JDBC连接数据库：

1）加载jdbc驱动程序；2）提供jdbc连接的url，创建数据库连接；3）创建一个statement；4）执行sql语句；5）关闭jdbc对象

29.Oracle基本数据类型：

字符型：Char、Varchar2、Nvarchar2

大对象型：Blob--二进制数据，最大4G;Clob--字符数据，最大长度4G

数值型：Integer、Float、Real、Number、Eg:Number(m,n)

日期型：Date、Timestamp

30.高并发解决方案

1）BAT类大公司：硬件方面：全国范围内集群；软件方面，自己研发核心数据处理程序

扩展性强，处理高并发能力很强，但研发成本和运维成本高

2）外包给BAT解决，如12306。省时省力，研发运维成本很低，但外部因素高，容易泄露商业机密或敏感数据

3）数据库加锁，加锁或用户量大都会造成排队，可以采用mycat集群实现数据库读写分离或者库表散列、redis集群+缓存，此外，大量用户会出现页面打开速度慢，使用tomcat服务器+nginx反向代理实现负载均衡

此外，使用html静态化、图片服务器分离、CDN加速技术

31.aop的应用

AOP即面向切面编程，是一种设计思想，是oop思想的延伸

应用：拦截器、事务、缓存、写日志

性能监视：通过日志记录方法运行时间

事务管理：将开启事务，提交事务，回滚事务操作放入aop中，目标中只需要执行sql语句

安全检查：判断用户是否具有目标方法访问权限，没有组织访问

缓存：在aop代理中，将第一次访问返回数据结果放入缓存，后面每次访问直接从缓存中获取数据

实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。

底层机制：底层是代理，分为动态代理和静态代理。动态代理在虚拟机内部动态构造，静态代理由用户手动编写代理类，对目标类代理。

动态代理实现技术：JDK动态代理、Cglib动态代理、javassist代理

spring底层使用JDK动态代理+Cglib动态代理

JDK动态代理基于接口进行代理，CGlib是为目标类创建代理对象，支持对目标类之间代理，无需接口

32.主从复制：

用来建立一个和主数据库完全一样的数据库环境，称为从数据库

主从复制的作用：1）.做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库中；2）架构的扩展：业务量越来越大，I/O频率访问过高，单机无法满足，做多库的存储，降低磁盘访问的频率，提高单个机器的I/O性能；3）读写分离：使数据库能支撑更大的并发。

原理：数据库有个bin-log二进制文件，记录了所有sql语句，把主数据库的bin-log文件的sql语句复制过来，让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可

33.String源码：

String是final类型的，不能被继承，实现了serializable接口，支持序列化和反序列化，String字符串是常量，基于字符数组实现的，其值在实例创建后不能修改。String对“+”的重载：String对象可以通过“+”串联或concat串联，实质上是调用了stringbuffer的append方法和toString方法

String、StringBuffer、StringBuilder区别：

执行速度：StringBuilder>StringBuffer>String

原因：1.String是字符常量，StringBuilder、StringBuffer是字符变量，String为常量，进行字符拼接时，JVM会临时创建一个同名变量接收，之前的同名变量通过垃圾回收释放内存，而StringBuffer、StringBuffer都是字符变量，对它们的赋值都是在同一个对象上操作的，不存在GC回收、新对象的创建操作。

2.StringBuffer和StrinigBuilder比较：

StringBuffer是线程安全的，StringBuilder是非线程安全的，当字符缓冲区被多个线程使用时，JVM不能保证StringBuilder操作的安全性，但StringBuffer是安全的。大多数情况下，都是单线程操作，建议使用StringBuilder。

34.list接口：

有序，可重复，定义了add、remove、set、get方法

主要子类：ArrayList、LinkedList、Vector

arraylist:底层数据结构是数组，默认长度10,1.5倍增长，优缺点：查询快，增删慢，线程不安全，效率高；

linkedlist:底层数据结构是双向链表,数据结构可以称为节点，且头结点中不存放数据，节点包括业务数据，前一个节点位置信息和后一个节点位置信息；优缺点：查询慢，增删快，线程不安全，效率高，扩容是容量自动加一

vector：ArrayList的前身，默认容量10，每次扩容1倍，线程安全，效率低。

35.Map接口：

无序，唯一,使用key-value来映射和存储数据，key唯一，value可重复

主要子类：hashMap、hashTable、treeMap

hashMap:基于数组和链表实现，允许使用null值和null键，不是线程安全的，主要是通过key的hashCode来计算hash值外加取余来获取索引，这个索引可以认为是一种地址，把相应的value存储在地址指向内容中，通过key-value映射到表中的位置，加快查找的速度；默认容量16，每次扩容为原来容量的2倍

hashtable原理和hashmap基本一样，方法中加了synchronized关键字，线程安全，默认容量11，每次扩容为原来容量的2倍加2

TreeMap基于红黑树实现

36.算法：

冒泡排序：外层减一，内层减i减一;选择排序：外层减一，内层j=i+1

二叉树：一个节点上最多二个子节点

1）在二叉树的第i层上最多有2 i-1 个节点 。（i>=1）

2）二叉树中如果深度为k(有k层),那么最多有2k-1个节点。(k>=1）

3）若二叉树按照从上到下从左到右依次编号，则若某节点编号为k，则其左右子树根节点编号分别为2k和2k+1;

4）二叉树分类：满二叉树，完全二叉树

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/75b3f9e486f7494c8211516a9f837241/clipboard.png)

先序遍历：10->6->4->8->14->12->16   先访问根节点，再访问左孩子和右孩子

中序遍历：4->6->8->10->12->14->16 

后序遍历：4->8->6->12->16->14->10   

层次遍历：10->6->14->4->8->12->16   按照所在层数，从下往上遍历

37.防止表单重复提交

<https://blog.csdn.net/qq_34368762/article/details/79130198>

1）js禁掉提交按钮：表单提交后使用Javascript使提交按钮disable，防止用户多次点击按钮；2）使用Post/Redirect/Get模式：在提交后执行页面重定向，这就是所谓的Post-Redirect-Get (PRG)模式。当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题；3）在session中存放一个特殊标志：在服务器端，生成一个唯一的标识符，将它存入session，同时将它写入表单的隐藏字段中，然后将表单页面发给浏览器，用户录入信息后点击提交，在服务器端，获取表单中隐藏字段的值，与session中的唯一标识符比较，相等说明是首次提交，就处理本次请求，然后将session中的唯一标识符移除；不相等说明是重复提交，就不再处理。这使你的web应用有了更高级的XSRF保护；4）使用header函数转向；5）表单过期的处理；6）判断表单动作的技巧；7）在数据库里添加约束：在数据库里添加唯一约束或创建唯一索引，防止出现重复数据。这是最有效的防止重复提交数据的方法；8）使用Cookie处理：使用Cookie记录表单提交的状态，根据其状态可以检查是否已经提交表单，如果客户端禁止了Cookie，该方法将不起任何作用

38.tomcat调优：

1）配置tomcat管理员账户；2）tomcat的3种运行方式：默认bio模式，性能低下，没有经过任何优化；nio模式是一个基于缓冲区、并能提供非阻塞I/O操作的java API,有更好的并发处理性能；apr模式：安装困难，但从操作系统级别来解决异步I/O问题，大幅提升性能；3）执行器，即线程池，每一个用户请求都是一个线程，可以使用线程池提高性能；4）对连接器（Connector）进行设置，连接器有2种，一种http connector，一种ajp connector,可以对http连接器进行设置，禁用ajp连接器

39.基础知识

java基本数据类型：4类8种：byte、short、int、long、float、double、char、boolean

重写和重载的区别：重写是父类与子类之间的多态性，对父类函数重新定义。子类与父类有相同的名称和参数和返回值，重载是一个类中的多态性表现，在类中定义了多个同名方法，参数类型不同或顺序不同或个数不同都将构成重载，与返回值无关

常见的异常：空指针异常、类型强制转换异常、数组下标越界异常、数组负下标异常、文件未找到异常、字符串转换为数字异常、操作数据库异常、输入输出异常。

集合类型：分为Map和collection，collection包括list和set。

40.分布式集群架构

![img](F:/%E6%9C%89%E9%81%93%E7%AC%94%E8%AE%B0/qq194D7B7F7185AC8C48FDFFE43294A88A/684aaa72adcc4fe5bded974dbcf18c12/clipboard.png)

41.java克隆机制：

原始变量与拷贝变量指向相同的引用对象，如果改变其中一个对象的状态，其他的对象变量的对象状态也会随之改变。分为浅拷贝和深拷贝

1）实现cloneable接口；2）使用public修饰clone方法，对clone方法进行重新定义

42.跨域请求：

1）nginx反向代理；2）jsonp跨域；3）html5特性，window.postMessage（）

43.不同的tomcat使用同一session

nginx+tomcat集群、redis将缓存的session持久化

44.freemarker

模板引擎，一个基于模板生成文本输出的通用工具，分离表现层和业务逻辑，jsp文件执行时转化为servlet执行，使用freemarker大幅度提高开发效率

45.JVM内存模型

46.电商模式分类

B2C:商对客   ；B2B：企业对企业      ；C2C:个人对个人

47.nginx+tomcat处理请求：

用户发送请求，nginx通过访问链接的域名不同找到对应的server服务器，根据location路径，路由到对应的服务，如果请求域名与任何server都不匹配时，会路由到默认的服务，这是通过listen实现的

48.mybatis返回类型

针对查询：返回一般数据类型、返回javaBean、返回list、返回map

针对增删改：返回integer、boolean

49.maven的作用

管理jar包、工程依赖、自动打包、搭建本地仓库或私服

50.TCP/IP协议

网络协议：用于多台计算机之间相互传递信息、数据所使用的规则

分为：应用层、传输层、网络层、数据链路层

sql语句的执行顺序

使用cookie的优缺点：

使用 Cookie 的优点为：

可配置到期时间；不需要任何服务器资源： Cookie 存储在客户端并在发送后由服务器读取；简单性（键值对）；数据持久性

使用 Cookie 的缺点为：

大小受到限制（一般4k）;用户配置为禁用;潜在的安全风险 Cookie 可能会被篡改。



防止客户直接访问URL进行操作：采用URL动态化-------------在URL后添加随机数作为参数



web攻击方式以及防御方式

XSS攻击：跨站脚本攻击，指攻击者在网页中嵌入恶意脚本程序

比如输入数据<script>...,变成了代码，防御措施：对输入的数据进行转义处理和HttpOnly（防范XSS攻击者窃取Cookie数据）

SQL注入：通过SQL命令伪装成正常的HTTP请求参数，传递到服务器端，服务器执行SQL命令造成对数据库进行攻击（Struts 2的高危漏洞就是通过OGNL实施OS注入攻击导致的）

比如进行查询操作时输入密码，‘ or  1=1',当进行查询数据库操作时，会拼接密码为password='' or 1=1 ，这样就跳过了密码的验证，更严重些输入的是对数据库有破坏性操作的指令，如’；drop table  ',会在执行查询后删除数据库。

防御方式：1）使用预编译语句，这样即使使用SQL语句伪造成参数，到了服务器端也只是普通的字符，不能起到攻击的作用；2）很多ORM框架已经可以对参数进行转义；3）MD5加盐加密

CSRF攻击：跨站请求伪造，通过伪装成受信任用户进行访问。（现实中不存在）

被攻击原因：用户本地存储cookie，攻击者利用用户的cookie进行认证，然后伪造用户发出的请求

防御方式：不用cookie来进行验证，可以采用token（不存储于浏览器）认证；验证码；通过referer识别，HTTP referer是header的一部分，浏览器向web服务器发送请求时一般会带上referer，告诉服务器是从哪个页面链接过来的，服务器基于此可以获得一些信息用于处理。

DDOS攻击：分布式拒绝服务攻击，发送大量请求使服务器瘫痪，基于DOS攻击基础上的，DOS是单挑，DDoS是群殴，攻击者借助公共网络，将大量设备联合起来，向一个或多个目标进行攻击

防御方式：增加带宽；云服务提供商有自己的一套完整DDoS解决方案



solr搜索：搜索默认采用or模式，可以修改为and（对搜索的词不进行拆分），也可进行百分比设置搜索匹配率











运维工程师：

事件管理（发现问题、处理问题、跟踪问题、发布管理）







反射：

团队开发应该注意什么？



并发量一万，tomcat并发量450就已经急剧下降，增长人数大致为在线人数的1/10左右



Oracle数据类型

高并发解决问题









